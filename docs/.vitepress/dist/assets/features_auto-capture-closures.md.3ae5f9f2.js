import{_ as e,c as l,a,b as s,d as o,e as p,o as t,r}from"./app.d9fbe7ee.js";const m=JSON.parse('{"title":"Auto-capture Closures","description":"","frontmatter":{},"headers":[{"level":2,"title":"Capturing by-value or by-reference","slug":"capturing-by-value-or-by-reference","link":"#capturing-by-value-or-by-reference","children":[]}],"relativePath":"features/auto-capture-closures.md"}'),c={name:"features/auto-capture-closures.md"},i={id:"auto-capture-closures",tabindex:"-1"},u=a("a",{class:"header-anchor",href:"#auto-capture-closures","aria-hidden":"true"},"#",-1),y=p(`<p>Since the introduction of arrow functions <code>fn () =&gt; ...</code> in PHP 7.4, many PHP developers have been looking for a solution to multi-line auto-capturing closures. The current solution to using out-of-scope variables inside of a closure involves specifying each variable inside of the function&#39;s <code>use</code> clause.</p><div class="language-php line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">wrap</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">Closure</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">callback</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Closure</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">use</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">($</span><span style="color:#A6ACCD;">callback</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">callback</span><span style="color:#89DDFF;">(...$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>An attempt to introduce auto-capturing closures was attempted in May 2022 (<a href="https://wiki.php.net/rfc/auto-capture-closure" target="_blank" rel="noreferrer">RFC</a>) but the vote was just shy of the 2/3 majority required to pass.</p><p>PXP follows this proposal very closely with its implementation of auto-capturing closures. Converting the <code>wrap()</code> function above would look something like below:</p><div class="language-pxp line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">pxp</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">wrap</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">Closure</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">$</span><span style="color:#A6ACCD;">callback</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Closure</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> {</span></span>
<span class="line"><span style="color:#A6ACCD;">        return $callback</span><span style="color:#89DDFF;">(...$</span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    };</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The <code>use</code> clause can be completely removed as PXP will handle the capturing automatically during transpilation.</p><h2 id="capturing-by-value-or-by-reference" tabindex="-1">Capturing by-value or by-reference <a class="header-anchor" href="#capturing-by-value-or-by-reference" aria-hidden="true">#</a></h2><p>As described by the <a href="https://wiki.php.net/rfc/auto-capture-closure" target="_blank" rel="noreferrer">RFC</a>, the surrounding environment is captured by-value. This means that trying to update the value of a variable will only affect the variable inside of the closure&#39;s own scope and not the surrounding scope.</p><p>The only exception to this rule is updating / interacting with a variable that holds an object, since the underlying value is still a reference to an object in memory. This behavour is consistent with arrow functions.</p>`,9);function C(D,A,d,F,b,h){const n=r("Badge");return t(),l("div",null,[a("h1",i,[s("Auto-capture Closures "),o(n,{type:"tip",text:"implemented"}),s(),u]),y])}const g=e(c,[["render",C]]);export{m as __pageData,g as default};
